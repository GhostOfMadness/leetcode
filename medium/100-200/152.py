"""
Maximum Product Subarray.

Найти непустой последовательный подмассив, произведение всех элементов
которого максимально.

Используем динамическое программирование. dp[i] фиксирует минимальное и
максимальное значение для подмассива, оканчивающегося на i-м индексе.
Для 0-го элемента это он сам, то есть dp[0] = (nums[0], nums[0]).
ans изначально равен 0-му элементу.

Пусть есть массив [-2, 3, 8], dp = (-2, -2), e = 3. Текущий максимум равен
0-му элементу, то есть -2, поэтому при умножении на 3 даст -6, что меньше
3. То есть произведение для максимального подмассива, заканчивающегося на
1-м элементе, равно 3 (самому 1-му элементу). Минимальное равно -6, значит
dp = (-6, 3). e = 8. В этом случае нужно проверить подмассивы [8], [3, 8] и
[-2, 3, 8]. То есть к 8 нужно "добавить" результаты подмассива, закончившегося
на 3. Тот максимум является положительным как и текущее число, поэтому для
нового максимума их нужно перемножить. Минимум отрицательный, поэтому тоже
умножаем его на 8, получаем dp = (-48, 24). При таком подхрде достаточно
хранить только результат предыдущего шага, поэтому весь массив dp не нужен,
будем просто обновлять кортеж значений.

Пусть текущее число e неотрицательное. Если текущий минимум положительный,
то новым минимумом будет текущее число, так как произведение 2-х положительных
целых чисел точно не меньше любого из этих чисел. В ином случае, умножаем
текущее число на минимум. С максимумом обратная ситуация. Умножаем число на
максимум, если он положительый, и берем само число в ином случае.

Для отрицательных чисел эти рассуждения повторяются в перевернутом виде.
Если максимум положительный, то новым минимумом будет произведение текущего
числа на максимум. В противоположном случае это будет само число, так как
любое произведение двух отрицательных чисел (а если максимум отрицательный,
то и минимум тоже) даст положительное число. Если минимум положительный,
то новым максимумом будет само число, если нет - проиведение минимума и числа.

Таким образом, то, что для неотрицательного числа будет минимумом и
максимумом, для отрицательного будет максимумом и минимумом соответственно.

Лучшее решение: 1 ms, 18.39 Mb
"""


class Solution:

    def maxProduct(self, nums: list[int]) -> int:
        dp = (nums[0], nums[0])
        ans = dp[1]
        for i in range(1, len(nums)):
            e = nums[i]
            f = e if dp[0] > 0 else e * dp[0]
            s = e * dp[1] if dp[1] > 0 else e
            dp = (f, s) if e >= 0 else (s, f)
            if dp[1] > ans:
                ans = dp[1]
        return ans
