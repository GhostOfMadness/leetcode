"""
Generate Parentheses.

Дано целое число n, задающее количество пар скобок. Необходимо сгенерировать
все правильные скобочные последовательности из этого числа скобок.
Испоьзуются только круглые скобки.

Создаем 2 параметра класса: ans - массив, куда будут заноситься полученные
ответы, n - общая длина последовательности, равная 2 * исходное число n.

Аргументы функции rec:
- now_open - кол-во скобок, которые открыты в данный момент.
- open_cnt - общее кол-во скобок, которые открыты сейчас или были открыты
  и закрыты ранее.
- curr - текущая последовательность.
- curr_len - длина текущей последовательности.

Если длина текущей последовательности равна предельной длине, то заносим
в ответ полученный результат. В ином случае ставим следующую скобку. Если
общее количество открытых скобок меньше половины предельной длины, то можно
поставить открывающую скобку, увеличив счетчики now_open и open_cnt. Если
на данном этапе открыты какие-то скобки (now_open > 0), то можно поставить
и закрывающую скобку, уменьшив now_open. Таким образом, когда рекурсия доходит
до предельной длины, то в curr точно правильная последовательность и проверка
не требуется.

Лучшее решение: 0 ms, 17.86 Mb
"""


class Solution:

    def rec(
        self,
        now_open: int = 0,
        open_cnt: int = 0,
        curr: str = '',
        curr_len: int = 0,
    ):
        if curr_len == self.n:
            self.ans.append(curr)
        else:
            if open_cnt < self.n >> 1:
                self.rec(now_open + 1, open_cnt + 1, curr + '(', curr_len + 1)
            if now_open:
                self.rec(now_open - 1, open_cnt, curr + ')', curr_len + 1)

    def generateParenthesis(self, n: int) -> list[str]:
        self.ans = []
        self.n = 2 * n
        self.rec()
        return self.ans
