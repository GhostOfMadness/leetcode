"""
Partition Equal Subset Sum.

Дан массив целых положительных чисел. Определить, можно ли разбить этот массив
на две части таким образом, чтобы сумма элементов в них совпадала.

Если сумма всех чисел нечетная, то разбиение заведомо невозможно. В ином
случае, используем динамическое программирование. Нужно определить, можно
ли получить половину общей суммы, используя элементы массива. Это очень похоже
на задачу о рюкзаке без стоимости предметов, когда нужно просто заполнить
определенный объем. Поэтому действуем схожим образом. Создаем массив dp
размером до половины суммы включительно, где dp[i] - булево значение,
показывающее можно ли получить сумму i из набора элементов. Внешним циклом
проходимся по элементам массива (num). Внутренним циклом проходимся по всем
значениям сумм от half - num до 0 (именно справа налево). Если dp от этого
значения равно True, то есть сумма достижима каким-то набором элементов,
не включая текущий, то и i + num также достижима, то есть dp[i + num] = True.
Если на каком-то этапе половина общей суммы достигнута, то возвращаем True
и прерываем цикл.

Лучшее решение: 261 ms, 19.25 Mb
#dynamic_programming #array
"""


class Solution:

    def canPartition(self, nums: list[int]) -> bool:
        total = sum(nums)
        if total % 2:
            return False
        half = total // 2
        dp = [False] * (half + 1)
        dp[0] = True
        for num in nums:
            for i in range(half - num, -1, -1):
                if dp[i]:
                    dp[i + num] = True
            if dp[half]:
                return True
        return False
