"""
Fraction to Recurring Decimal.

Дан числитель и знаменатель дроби. Необходимо перевести эту дробь в десятичную
запись. Если дробь является периодической, то период указывается в скобках.

Сначала определяем знак итогового числа. Если знаки числителя и знаменателя
не совпадают, то число будет отрицательным, иначе - положительным. При делении
удобнее работать с положительными числами, поэтому используем модуль
знаменателя. Сначала определяем целую часть числа, которая стоит перед точкой,
и остаток, который умножаем на 10. Также создаем массив arr, в который будем
добавлять цифры после запятой и словарь d. В этом словаре будем хранить пары
"остаток - индекс элемента, для получения которого использовался этот остаток".
idx как раз задает этот индекс.

Если остаток уже есть в словаре, то дробь является периодической, сам период
начинается от d[mod] и идет до конца массива arr. В этом случае выходим из
цикла. В общем случае заносим остаток в словарь, делим этот остаток на
знаменатель, результат деления заносим в arr, а остаток умножаем на 10 и
используем в следующей итерации. Также увеличиваем idx на 1 для поддержания
его актуального состояния.

Если после цикла остаток равен 0, то числитель полностью разделился на
знаменатель. Если arr пуст, то ответом будет только целая часть со знаком.
В ином случае, склеиваем цифры в arr и добавляем их к целой части.

Если остаток не стал 0, то дробь является периодической. d[mod] задает начало
периода. При повторе остатка сразу идет выход из цикла, поэтому период идет
до конца arr. В ответ идет целая часть со знаком, точка, набор цифр до периода
и сам период в круглых скобках.

Лучшее решение: 0 ms, 17.92 Mb
#hash_table #math
"""


class Solution:

    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        sign = ''
        if (
            (numerator < 0 and denominator > 0)
            or (numerator > 0 and denominator < 0)
        ):
            sign = '-'
        den = abs(denominator)
        div, mod = divmod(abs(numerator), den)
        mod *= 10
        arr = []
        idx = 0
        d = dict()
        while mod != 0:
            if mod in d:
                break
            d[mod] = idx
            arr.append(mod // den)
            mod = (mod % den) * 10
            idx += 1
        if mod == 0:
            if arr:
                return f'{sign}{div}.{"".join(map(str, arr))}'
            return f'{sign}{div}'
        idx = d[mod]
        return (
            f'{sign}{div}.{"".join(map(str, arr[:idx]))}'
            f'({"".join(map(str, arr[idx:]))})'
        )


if __name__ == '__main__':
    res = Solution()
    test_cases = [
        (1, 2, '0.5'),
        (2, 1, '2'),
        (4, 333, '0.(012)'),
        (314159, 100000, '3.14159'),
        (1, 3, '0.(3)'),
        (1, 9, '0.(1)'),
        (1, 81, '0.(012345679)'),
        (22, 7, '3.(142857)'),
        (593, 53, '11.(1886792452830)'),
        (1, 44, '0.02(27)'),
        (1, 56, '0.017(857142)'),
        (-50, 8, '-6.25'),
        (7, -12, '-0.58(3)')
    ]
    for num, den, ans in test_cases:
        my_ans = res.fractionToDecimal(num, den)
        if ans != my_ans:
            print(f'num = {num}, den = {den}, ans = {ans}, my_ans = {my_ans}')
