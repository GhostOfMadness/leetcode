"""
Minimum Operations to Make the Integer Zero.

Даны 2 целых числа num1 и num2. На каждом шаге выбирается значение i на
отрезке [0, 60] и из num1 вычитается 2 ** i + num2. Найти минимальное
количество операций, за которое число num1 станет равным 0, или вывести -1,
если это невозможно.

Пусть мы сделали одну операцию, то есть вычли из num1 num2 и какую-то степень
двойки. Этой операции достаточно для преобразования, если эта степень двойки
равна num1 - num2. Если сделали 2 операции, то в виде суммы степень двойки
нужно представить num1 - 2 * num2, 3 операции - num1 - 3 * num3 и т.д. То есть
после k операций нужно разложить число num1 - k * num2 = rem. Минимальное
количество операций для его разложения равно rem.bit_count() - количество
единичных бит в числе. Это количество уникальных степеней двойки для получения
числа, которое можно разбить на до максимум rem повторяющихся степеней. Таким
образом, вычитаем num2, пока кол-во единичных бит больше числа k. При этом
важно учесть, что степень двойки всегда больше 0. Если rem стал меньше k,
то мы никак не получим его за k операций, так как даже если всегда брать
2 ** 0, то за k операций это даст k. В этом случае разложение невозможно.

Лучшее решение: 0 ms, 17.68 Mb
#math #bit_manipulation
"""


class Solution:

    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        k = 1
        curr = num1 - num2
        while curr >= k and k < curr.bit_count():
            k += 1
            curr -= num2
        if curr < k:
            return -1
        return k
