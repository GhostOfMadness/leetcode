"""
Trionic Array II.

Дан массив целых чисел nums. Подмассив nums[l...r] (0 <= l < r < len(nums))
называется трионическим (trionic), если можно найти такие индексы p и q,
что l < p < q < r, nums[l...p] - строго возрастает, nums[p...q] - строго
убывает, nums[q...r] - строго возрастает. Найти наибольшую сумму элементов
в трионическом подмассиве. Гарантируется, что в массиве nums есть хотя бы
один такой подмассив.

В некоторой мере используем метод двух указателей. Сначала определяем границы
left и right как 0 и len(nums) - 1. Это область поиска первого триоонического
подмассива. На каждой итерации внешнего цикла ищем очередной подмассив. Первый
внутренний цикл while позволяет определить индекс окончания возрастания
значений элементов, которое начинается в left. Так находим p. Второй цикл
while находит конец убывающей подпоследовательности - индекс q. Третий цикл
находит правую границу подмассива - текущее значение i. Если выполняется
неравенство l < p < q < i, то подмассив подходит под условие, поэтому нужно
знать его наибольшую сумму. Это необязательно должна быть сумма всех элементов.
Элементы nums[p...q] точно включаются в ответ, потому что убывающий участок
находится внутри подмассива. А вот возрастающие последовательности слева и
справа можно брать не полностью. Для значения слева нужно взять максимальный
суффикс nums[l...p], а для значения справа - префикс nums[q...i]. Так как
подпоследовательности упорядочены по возрастанию, то для левой части стоит
брать либо сумму всех неотрицательных элементов (они заведомо располагаются
после отрицательных, формируя суффикс), либо сумму двух последних элементов,
если все числа отрицательны. Для правой части берем максимум из суммы всех
значений этого участка и суммы двух первых чисел. Сравниваем общий результат
с текущим ответом и заносим в ответ максимум. После этого сдвигаем left на
q, а p на i, так как правая возрастающая подпоследовательность может быть
началом следующего трионического подмассива. Также нужно знать сумму
положительных значений на этом участке, чтобы не делать повторных вычислений,
поэтому в третьем цикле while считаем и ее тоже, хотя для ответа на текущей
итерации она не нужна. Если подмассив не является трионическим, но его правая
часть возрастает (q < i), то проводим такие же сдвиги индексов и замену
значений. Если возрастания нет, то сдвигаем индекс i, пока элементы равны,
и ставим left на полученную позицию i.

Переменные внутри функции:
- left - левая граница области поиска.
- right - правая граница области поиска.
- p - индекс перегиба с возрастания на убывание.
- q - индекс перегиба с убывания на возрастание.
- fpos - сумма положительных значений на nums[left...p - 1].
- decsum - сумма всех значений на nums[p...q - 1]
- tpos - сумма положительных значений на nums[q...i - 1]
- ttotal - сумма всех значений на nums[q...i]

Таким образом, значения nums[p] и nums[q] учитываются в ответе по 1 разу.

Лучшее решение: 93 ms, 31.46 Mb
#array #two_pointers
"""


class Solution:

    def maxSumTrionic(self, nums: list[int]) -> int:
        left, right = 0, len(nums) - 1
        p, q = None, None
        fpos, decsum, tpos, ttotal = 0, 0, 0, 0
        ans = float('-inf')
        i = 0
        while i < right:
            if p is None:
                while i < right and nums[i] < nums[i + 1]:
                    if nums[i] > 0:
                        fpos += nums[i]
                    i += 1
                p = i
            while i < right and nums[i] > nums[i + 1]:
                decsum += nums[i]
                i += 1
            q = i
            while i < right and nums[i] < nums[i + 1]:
                ttotal += nums[i]
                if nums[i] > 0:
                    tpos += nums[i]
                i += 1
            ttotal += nums[i]
            if left < p < q < i:
                curr = decsum + max(ttotal, nums[q] + nums[q + 1])
                if not fpos:
                    curr += nums[p - 1]
                else:
                    curr += fpos
                ans = max(ans, curr)
                left, p = q, i
                fpos = tpos
                decsum, tpos, ttotal = 0, 0, 0
            elif q < i:
                left, p = q, i
                fpos = tpos
                decsum, tpos, ttotal = 0, 0, 0
            else:
                while i < right and nums[i] == nums[i + 1]:
                    i += 1
                left = i
                p, q = None, None
                fpos, decsum, tpos, ttotal = 0, 0, 0, 0
        return ans
