"""
Longest Common Subsequence.

Найти длину наибольшей общей подпоследовательности для двух строк.

Используем динамическое программирование. dp[i][j] - НОП для префиксов
text1[:i + 1] и text2[:j + 1]. Если text1[i] и text2[j] совпадают, то они
включаются в НОП, поэтому к максимальной длине НОП без них (dp[i - 1][j - 1])
прибавляем 1. Если символы не совпадают, то выбираем максимум из ответа
без text1[i] (dp[i - 1][j]) или без text2[j] (dp[i][j - 1]). В итоге,
if text1[i] == text2[j]:
    dp[i][j] = dp[i - 1][j - 1] + 1
else:
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

Для определения текущего значения необходимо знать только предыдущую строку,
то есть можно перезаписывать текущую и предыдущую строки на каждом цикла и не
хранить все матрицу dp, что позволяет уменьшить потребление памяти. Исходная
строка prev состоит из 0, так как длина НОП пустой строки с text2 всегда равна
нулю. Длина prev на 1 больше, чем длина text2, чтобы не обрабатывать первое
значение без соседей слева отдельно.

Лучшее решение: 211 ms, 19.45 Mb
#dynamic_programming #string
"""


class Solution:

    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        len2 = len(text2)
        prev = [0] * (len2 + 1)
        for letter1 in text1:
            curr = [0] * (len2 + 1)
            i = 1
            for letter2 in text2:
                if letter1 == letter2:
                    curr[i] = prev[i - 1] + 1
                else:
                    curr[i] = max(prev[i], curr[i - 1])
                i += 1
            prev = curr
            del curr
        return prev[len2]
