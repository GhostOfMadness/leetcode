"""
Maximum Score From Removing Substrings.

К строчке можно применить 2 операции:
- удалить подстроку 'ab' и получить x очков.
- удалить подстроку 'ba' и получить y очков.
Операции можно применять любое количество раз, пока эти подстроки остаются
в строке. Найти максимальную сумму очков, которую можно получить после
применения всех операций.

Важно учесть, что конкатенация 2-х частей строки после удаления подстроки
также может дать новую подходящую подстроку. Например, если в 'abab' удалить
'ba', то останется 'ab', которую также можно удалить.

Заведем стек, в который будем добавлять только буквы 'a' и 'b'. Если x >= y,
то выгоднее удалять подстроки 'ab'. То есть буквы 'a' просто кладем в стек,
а для буквы 'b' проводим проверку: если последний элемент стека равен 'a',
то удаляем его и увеличиваем ответ на x, иначе - просто добавляем 'b'. При
таком подходе стек всегда будет состоять из последовательности букв 'b'
(возможно пустой), за которыми следуют буквы 'a'. То есть вместо проверки
последнего элемента стека можно проверить, что в стеке вообще есть 'a'.
Когда получили какой-то другой символ, то в ответ добавляем y, умноженный
на минимум из кол-ва значений букв 'a' и 'b', структура стека позволяет
сделать такой переход. Также обнуляем стек и счетчики.

Если y > x, то все наоборот. Поэтому в first хранится приоритетная буква,
то есть та, которая выталкивает из стека последний элемент и увеличивает
ответ.

Лучшее решение: 184 ms, 18.88 Mb
"""


class Solution:

    def maximumGain(self, s: str, x: int, y: int) -> int:
        max_val = max(x, y)
        min_val = min(x, y)
        first = 'b'
        second = 'a'
        if x < y:
            first, second = second, first
        ans = 0
        fcnt = scnt = 0
        stack = []
        for letter in s:
            if letter in 'ab':
                if letter == first:
                    if scnt:
                        ans += max_val
                        stack.pop()
                        scnt -= 1
                    else:
                        stack.append(letter)
                        fcnt += 1
                else:
                    stack.append(letter)
                    scnt += 1
            else:
                ans += min_val * min(fcnt, scnt)
                stack = []
                fcnt = scnt = 0
        ans += min_val * min(fcnt, scnt)
        return ans
