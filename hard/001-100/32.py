"""
Longest Valid Parentheses.

Дана скобочная последовательность из круглых скобок. Найти длину наибольшей
непрерывной правильной скобочной последовательности (ПСП) внутри исходной.

С помощью стека можно за линейное время проверить последовательность на ПСП,
но перебор всех пар индексов с такой проверкой займет O(n ** 3), что очень
долго. Но сама идея стека подходит, только вместо простого хранения открытых
скобок будем хранить размеры ПСП, которая закрылась внутри текущего отрезка.

Создаем пустой стек, а также значение buff, которое пригодится, если стек
опустеет, но какой-то размер ПСП накоплен. Если встретили в строке открывающую
скобку, то кладем в стек 0, так как пока не прошли дальше и никакую ПСП не
нашли. Если встретили закрывающую скобку, то здесь уже два варианта действий.
Если стек пуст, то незакрытых скобок нет и новую ПСП сформировать не получится.
В этом случае обнуляем буфер buff, так как слева от этой закрывающей скобки
могла быть ПСП, но текущая закрывающая скобка не позволяет ее добавить к
какой-либо другой ПСП после нее. Если стек не пустой, то заведомо получаем
ПСП размера минимум 2, так как текущая скобка закрывает какую-то другую.
Значение на вершине стека соответствует открывающей скобке и показывает размер
ПСП внутри закрываемого участка. ПСП внутри ПСП = ПСП, поэтому снимаем элемент
с вершины стека и прибавляем его к 2. Но ПСП могла быть не только внутри, но
и слева от закрытой скобки, а две ПСП подряд = ПСП. Поэтому смотрим на новый
элемент на вершине стека или буфер, если стек опустел, и также прибавляем его
к текущему ответу. На вершину стека или в буфер кладем полученный результат,
так как это как раз размер закрытой ПСП справа от предыдущей открытой скобки.
Сраниваем текущий результат с ответом и обновляем его при необходимости.

Лучшие результат: 3 ms, 19.85 Mb
#stack #dynamic_programming #string
"""


class Solution:

    def longestValidParentheses(self, s: str) -> int:
        stack = []
        buff = 0
        ans = 0
        for e in s:
            if e == '(':
                stack.append(0)
            elif stack:
                curr = 2 + stack.pop()
                if stack:
                    curr += stack.pop()
                    stack.append(curr)
                else:
                    curr += buff
                    buff = curr
                if curr > ans:
                    ans = curr
            else:
                buff = 0
        return ans
