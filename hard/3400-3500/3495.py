"""
Minimum Operations to Make Array Elements Zero.

Дан двумерный массив запросов queries, где каждый запрос представляет собой
левую и правую границу отрезка включительно. За один шаг можно выбрать 2 любых
целых числа из этого отрезка и заменить каждое из них на округленный вниз
результат деления на 4. Необходимо найти минимальное количество шагов, за
которое можно привести все числа на отрезке к 0, и суммировать результаты
для каждого запроса.

Деление на 4 - это битовый сдвиг вправо на 2 бита, поэтому для каждого числа
количество операций определяется как округленный наверх результат деления
кол-ва бит в числе на 2. Например, если в числе 6 бит, то нужно 3 операции,
11 бит - 11 / 2 = 5.5 -> 6 операций. При этом важно учесть, что числа на
отрезке идут друг за другом, то есть нет скачков кол-ва операций. Сначала
требуется k ходов, после достижения следующей за левой границей степенью 4
нужен k + 1 шаг, затем k + 2 и т.д. Например, для чисел на отрезке [0, 3]
нужна 1 операция, [4, 15] - 2 операции, [16, 63] - 3 операции. Такой плавный
переход позволяет разбить весь исходный отрезок на подотрезки чисел с
одинаковым числом операций для достижения 0 и работать с каждым таким
подотрезком отдельно, а затем агрегировать результат. При этом работать
удобно именно с кол-вом операций, а не с самими числами.

Рассмотрим такой подотрезок с четным кол-вом чисел на нем (n) и кол-вом
операций k. В этом случае подотрезок разбивается на целое кол-во пар, каждая
из которых за k шагов обращается в нули. Всего пар n // 2, значит общее число
ходов = k * (n // 2).

Если n - нечетное, то также можно разбить подотрезок на пары и отработать их,
а затем за k операций свести оставшееся число к 0. В таком варианте потребуется
k * (n // 2) + k = k * (n // 2 + 1) ход. Например, [3, 3, 3] ->
3 * (3 // 2 + 1) = 6. Но это неэффективно, ведь можно сделать такую
последовательность [3, 3, 3] -> [2, 2, 3] -> [1, 2, 2] -> [1, 1, 1]
-> [0, 0, 1] -> [0, 0, 0]. Получили 5 ходов вместо 6. То есть за (n // 2) + 1
ход можно применить 1 операцию ко всем числам, а к какому-то одному числу - 2.
А за (n // 2) + 1 + (n // 2) = 2 * (n // 2) + 1 можно применить 2 операции
ко всем числам и снова получить массив чисел с одинаковым числом операций.
Поэтому для каждой двойки в числе k применяем 2 * (n // 2) + 1 операцию,
а для остатка (если есть) - n // 2 + 1 операцию. Таким образом, для нечетного
n получаем (k // 2) * (2 * (n // 2) + 1) + (k % 2) * (n // 2 + 1).

Также заметим, что на больших отрезках будут встречаться подотрезки, где
присутствуют все числа с некоторым k операций. Например, отрезок [2, 90]
включает в себя все числа с 2 и 3 операциями. При большом количество запросов
одни и теже расчеты будут повторяться много раз. Поэтому заранее насчитаем
кол-во операций на подотрезках от 1 до 14 операций (ограничение в 10 ** 9)
и найдем префиксные суммы такого массива (умещаются в 64 бита). Тогда для
каждого запроса расчет займет O(1).

Для каждого запроса сначала определяем кол-во операций для достижения 0 для
левой и правой границ. Если они совпадают, то и у чисел между ними такое же
кол-во операций, поэтому просто считаем кол-во ходов на отрезке по описанной
логике с четным и нечетным n (функция __cnt_operations). Если же значения
отличаются, то сначала находим размеры самого левого и правого подотрезков
исходного отрезка. Левый подотрезок идет от левой границы до ближайшей степени
4, то есть до 2 ** (2 * k_left). Правый подотрезок тоже ограничен степенью 4,
которая определяется как 2 ** (2 * k_right - 2). Только в случае с правым
подотрезом эта степень 4 включена в интервал, поэтому к n_right прибавляется
1. Ответ для всех значений от k_left + 1 до k_right - 1 находится из массива
префиксных сумм, для левого и правого подотрезов - из функции __cnt_operations.

Осталось учесть одну деталь. Если подотрезок имеет нечетную длину и кол-во
операций на нем нечетно, то последняя операция на нем применяется только к 1
числу. Если таким подотрезов 2 на отрезке, то вместо применения 2-х операций
к одному числу и 0, можно применить 1 операцию к оставшимся числам. То есть
из ответа нужно вычесть 1. Таких подотрезов не больше 2, потому что подотрезки,
для которых заранее считались ответы заведомо имеют четную длину.

Лучшее решение: 236 ms, 54.38 Mb
#math #bit_manipulation #prefix_sum
"""
import math


class Solution:

    def __cnt_operations(self, k: int, n: int):
        if n % 2 == 0:
            return k * (n // 2)
        return (k // 2) * (2 * (n // 2) + 1) + (k % 2) * (n // 2 + 1)

    def __get_prefix_sum(self):
        prefix = [0] * 15
        prefix[1] = 2
        n = 12
        for i in range(2, 15):
            prefix[i] = prefix[i - 1] + i * (n // 2)
            n *= 4
        return prefix

    def minOperations(self, queries: list[list[int]]) -> int:
        ans = 0
        prefix = self.__get_prefix_sum()
        for l, r in queries:
            k_left = math.ceil(l.bit_length() / 2)
            k_right = math.ceil(r.bit_length() / 2)
            if k_left == k_right:
                ans += self.__cnt_operations(k_left, r - l + 1)
            else:
                n_left = 2 ** (2 * k_left) - l
                n_right = r - 2 ** (2 * k_right - 2) + 1
                ans += prefix[k_right - 1] - prefix[k_left]
                cnt_left = self.__cnt_operations(k_left, n_left)
                cnt_right = self.__cnt_operations(k_right, n_right)
                ans += cnt_left + cnt_right
                if n_left % 2 and k_left % 2 and n_right % 2 and k_right % 2:
                    ans -= 1
        return ans
