"""
Divide an Array Into Subarrays With Minimum Cost II.

Дан массив целых чисел nums. Стоимостью подмассива считается величина его
первого элемента. Необходимо разделить nums на k подмассивов таким образом,
чтобы их суммарная стоимость была минимальна, а разница индексов начала
второго и последнего подмассивов была не больше dist.

Первый подмассив точно начинается с 0-го элемента, поэтому он прибавляется
к ответу. Дальше задача сводится к поиску k - 1 минимального значения на
скользящем окне размера dist + 1.

Решаем задачу с использованием бинарных куч. Текущий набор из k минимумов
сохраним в макс-куче heap, а в мин-куче addHeap будем собирать значения,
которые могут быть добавлены в heap при сдвиге окна. Изначально в heap берем
первые k - 1 элементов, начиная с первого и прибавляя их значения к ответу.
Далее проходимся по остальным значениям в окне. Если новый элемент меньше
максимума в heap, то есть heap[0], то снимаем значение с вершины heap и
перекладываем его в addHeap, а новый элемент кладем в heap. Ответ уменьшится
на разницу между снятым и новым элементом. Если новый элемент не превышает
heap[0], то просто добавляем его в addHeap. Эту логику можно реализовать с
помощью if-else, а можно каждое новое значение класть в heap, снимать максимум
после этого и добавлять его в addHeap. Если новое значение больше или равно
heap[0], то снимем его же, иначе - старый максимум.

Далее проходимся по остальным окнам. Создаем словари maxd и mind, чтобы
помечать удаленные из куч значения, так как в этой структуре данных нет
быстрого удаления произвольного элемента. old - элемент, который выпал из
окна, new - элемент, который повяился в окне. new сразу добавляем в addHeap.
Если old > heap[0], то выпавший элемент не входил в макс-кучу и не влиял на
ответ. Он был в куче addHeap, поэтому в словаре mind увеличиваем счетчик этого
значения на 1. Старое значение на ответ на влияло, но новое может повлиять,
если addHeap[0] < heap[0]. В этом случае уменьшаем текущий ответ на разницу
между addHeap[0] и heap[0] и меняем элементы на вершинах куч местами. Если
old <= heap[0], то выпавший элемент входил в кучу. В словаре maxd помечаем
еще одно его вхождение удаленным. Так как элемент удален из heap, то надо
обязательно добавить новый, то есть addHeap[0], так как он наименьший из
доступных. Корректируем текущий ответ на разницу addHeap[0] и old и
перекладываем addHeap[0] в heap. После этого обязательно "чистим" кучи, то
есть удаляем элементы с вершин heap и addHeap, пока они есть в словарях
maxd и mind соответственно. Если во время "чистки" какие-то значения словаря
стали нулями, то ключи с такими значениями удаляются. Такая "чистка"
гарантирует, что на вершинах куч к следующей итерации не будет удаленных
элементов. Если текущий результат меньше ответа, то обновляем ответ.

Лучшее решение: 229 ms, 33.63 Mb
#heap #sliding_window #hash_map
"""
import heapq


class Solution:

    def minimumCost2(self, nums: list[int], k: int, dist: int) -> int:
        ans = sum(nums[:k])
        heap = nums[1:k]
        heapq.heapify_max(heap)
        addHeap = []
        heapq.heapify(addHeap)
        for i in range(k, dist + 2):
            curr = heapq.heappushpop_max(heap, nums[i])
            heapq.heappush(addHeap, curr)
            ans += nums[i] - curr
        maxd, mind = {}, {}
        length = len(nums)
        currRes = ans
        for i in range(1, length - dist - 1):
            old, new = nums[i], nums[i + dist + 1]
            heapq.heappush(addHeap, new)
            if old > heap[0]:
                mind[old] = mind.get(old, 0) + 1
                if addHeap[0] < heap[0]:
                    currRes += addHeap[0] - heap[0]
                    curr = heapq.heappushpop_max(heap, heapq.heappop(addHeap))
                    heapq.heappush(addHeap, curr)
            else:
                maxd[old] = maxd.get(old, 0) + 1
                currRes += addHeap[0] - old
                heapq.heappush_max(heap, heapq.heappop(addHeap))
            while addHeap and addHeap[0] in mind:
                val = heapq.heappop(addHeap)
                mind[val] -= 1
                if not mind[val]:
                    mind.pop(val)
            while heap[0] in maxd:
                val = heapq.heappop_max(heap)
                maxd[val] -= 1
                if not maxd[val]:
                    maxd.pop(val)
            if currRes < ans:
                ans = currRes
        return ans
