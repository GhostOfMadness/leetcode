"""
Minimum ASCII Delete Sum for Two Strings.

Даны две строки, состоящие из строчных английских букв. Найти минимальную
сумму ASCII-кодов символов, которые нужно удалить, чтобы строки совпали.

Используем двумерное динамическое программирование. dp[i][j] - минимальная
стоимость преобразования префикса s1[:i + 1] в префикс s2[:j + 1]. Если
буквы s1[i] и s2[j] совпадают, то удалять их нет смысла и в качестве ответа
берется стоимость преобразования префикса s1[:i] в s2[:j], то есть
dp[i - 1][j - 1]. Если буквы не совпадают, то можно удалить символ s1[i] и
прибавить стоимость перевода s1[:i] в s2[:j + 1] = dp[i - 1][j] + ord(s1[i]),
или удалить s2[j] и учесть затраты на переход s1[:i + 1] в s2[:j] =
dp[i][j - 1] + ord(s2[j]). Можно удалить оба символа и взять стоимость
перевода s1[:i] в s2[:j], но это значение заведомо больше других вариантов,
так как dp[i - 1][j - 1] не может отличаться от соседа справа и снизу больше,
чем на 1 ASCII-код буквы, а разброс этих кодов мал. Таким образом,
if s1[i] == s2[j]:
    dp[i][j] = dp[i - 1][j - 1]
else:
    dp[i][j] = min(dp[i - 1][j] + ord(s1[i]), dp[i][j - 1] + ord(s2[j]))

Всю матрицу dp можно не хранить, так как на каждом шаге используются только
текущая и предыдущая строки.

Сразу переведем буквы строк в их числовые значения для ускорения сравнения
на равенство. Изначально предыдущая строка заполняется как стоимость перевода
строки 2 в пустую стсроку, то есть получаем аккумулированные значения суммы
кодов букв этой строки. В качестве первого столбца матрицы dp также удобно
использовать такие же аккумулированные значения для строки 1, чтобы не
обрабатывать первое значение без соседей слева отдельно. Поэтому в исходную
предыдущую строку на первое место ставим 0, а затем на каждом шаге внешнего
цикла будем увеличивать это значение на код очередной буквы строки 1 и ставить
его на первое место уже текущей строки. С помощью внешнего и вложенного цикла
реализуем сравнение символов строк и заполняем текущую строку. Затем ставим
ссылку предыдущей строки на текущую и переходим к следующей итерации. Ответ
находится в конце последней полученной строки.

Лучшее решение: 147 ms, 19.54 Mb
#dynamic_programming #string
"""
from itertools import accumulate
from string import ascii_lowercase as letters


class Solution:

    def minimumDeleteSum2(self, s1: str, s2: str) -> int:
        d: dict[str, int] = {letter: ord(letter) for letter in letters}
        ord_s1 = list(map(lambda e: d[e], s1))
        ord_s2 = list(map(lambda e: d[e], s2))
        len2 = len(s2)
        prev = [0] + list(accumulate(ord_s2))
        col_val = 0
        for e1 in ord_s1:
            col_val += e1
            curr = [col_val] * (len2 + 1)
            i = 1
            for e2 in ord_s2:
                if e1 == e2:
                    curr[i] = prev[i - 1]
                else:
                    curr[i] = min(
                        curr[i - 1] + e2,
                        prev[i] + e1,
                    )
                i += 1
            prev = curr
            del curr
        return prev[len2]
