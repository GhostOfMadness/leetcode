"""
Find Minimum in Rotated Sorted Array.

Дан отсортированный массив длины n, состоящие из уникальных целых чисел.
Массив был сдвинут вправо от 1 до n раз. Например, есть исходный массив
[0, 1, 2, 4, 5, 6, 7], тогда:
- [4, 5, 6, 7, 0, 1, 2] - сдвиг 4 раза.
- [0, 1, 2, 4, 5, 6, 7] - сдвиг 7 раз.
Необходимо найти минимальный элемент в данном массиве.

Используем бинарный поиск, чтобы определить количество сдвигов. По условию
их не меньше 1 и не больше n, поэтому эти значения и будут границами (обе
включены). Элемент в середине будем сравнивать с первым элементом массива.
Если средний элемент больше первого, то сдвиг точно находится правее левой
границы и сам средний элемент минимальным также не является, поэтому ставим
left на mid + 1. В ином случае, сдвигаем right на mid. В итоге, right будет
определять количество сдвигов, а остаток от деления right на длину массива
даст индекс минимума. Последний шаг необходим, так как если было n сдвигов,
то right будет указывать за пределы массива.

Лучшее решение: 0 ms, 19.36 Mb
#binary_search #array
"""


class Solution:

    def findMin(self, nums: list[int]) -> int:
        length = len(nums)
        comp = nums[0]
        left, right = 1, length
        while left < right:
            mid = (left + right) // 2
            if nums[mid] > comp:
                left = mid + 1
            else:
                right = mid
        idx = right % length
        return nums[idx]
