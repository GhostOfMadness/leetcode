"""
Broken Calculator.

На калькуляторе определены 2 операции: умножить текущее число на 2 или вычесть
из него 1. Найти минимальное количество операция для преобразования числа
startValue в target.

Идем в обратном направлении, то есть от target к startValue. Если target -
нечетное число, то в него можно прийти только из target + 1, так как умножение
на 2 точно не подходит. Если target - четное, то уже есть два варианта. Можно
дойти из target // 2 или из target + 1. Умножение на 2 позволяет пропустить
множество единичных шагов, поэтому этот вариант выгоднее. Проводим проверку
и меняем target, увеличивая счетчик на 1, пока target больше startValue.
Когда это условие перестанет выполняться, то добавляем к счетчику разность
startValue и полученного target и возвращаем найденное значение. Ситуация
startValue > target может быть изначально, а может появиться внутри цикла,
но и в этом случае выгоднее делать деление на 2 для четных чисел. Например,
startValue = 7, target = 10. Можно сделать * 2, а затем 4 раза вычесть по 1,
то есть получим 5 операций. А можно изначально дважды вычесть 1, а затем
умножить на 2, чтобы получить 3 операции, то есть сократить число операций
-1 в два раза. В обратном порядке как раз получаем деление на 2 и прибавление
разности для оптимального ответа.

Лучшее решение: 0 ms, 19.23 Mb
#math #greedy
"""


class Solution:

    def brokenCalc(self, startValue: int, target: int) -> int:
        cnt = 0
        while startValue < target:
            if target & 1:
                target += 1
            else:
                target >>= 1
            cnt += 1
        return cnt + startValue - target


res = Solution()
tests = [
    (2, 3, 2),
    (5, 8, 2),
    (3, 10, 3),
    (12, 10, 2),
    (7, 10, 3),
    (6, 10, 2),
    (8, 10, 4),
    (9, 10, 5),
]
for start, target, ans in tests:
    print(f'ans = {ans}, my ans = {res.brokenCalc(start, target)}')
