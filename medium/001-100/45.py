"""
Jump Game II.

Дан массив целых чисел. Каждое число задает максимальный размер шага, который
можно сделать с текущей позиции. Найти минимальное количество прыжков,
за которое можно попасть из первого элемента в последний. Гарантируется,
что последний элемент достижим.

Создадим массив dp, в котором будем хранить минимальное количество шагов
до каждого индекса. В переменной curr хранится максимальный индекс, который
можно достичь. Когда взяли новое значение, то считаем diff, то есть разницу
между i + nums[i] и curr. Это будет количество новых индексов, которые можно
достичь с текущей позиции. Индексы до них тоже достижимы с текущего места,
но дополнительный прыжок увеличит ответ для них, что неверно. Для новых
индексов в массив dp заносим dp[i] + 1. Увеличиваем curr на diff и сдвигаемся
на 1 вправо. Цикл продолжается, пока curr меньше n - 1, то есть последний
индекс еще не достигнут.

Лучшее решение: 23 ms, 18.58 Mb
"""


class Solution:

    def jump(self, nums: list[int]) -> int:
        n = len(nums)
        dp = [0] * n
        curr = 0
        i = 0
        while curr < n - 1:
            diff = max(0, i + nums[i] - curr)
            for j in range(curr + 1, min(n, curr + diff + 1)):
                dp[j] = dp[i] + 1
            curr += diff
            i += 1
        return dp[n - 1]
