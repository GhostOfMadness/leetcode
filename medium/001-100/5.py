"""
Longest Palindromic Substring.

Найти наибольшую подстроку, которая является палиндромом.

Используем динамическое программирование. Так как подстрока представляет
собой последовательно идущие символы, то для нахождения текущего ответа
достаточно знать только результат предыдущего шага. dp[i] - массив длин
всех палиндромов, которые заканчиваются на i-й позиции. prev - значение
предыдущего символа. В ответ будем заносить наибольшую длину палиндрома
и индекс его окончания.

Для каждого символа в dp будет входить 1, так как сам символ является
палиндромом. Если текущий символ равен предыдущему, то добавляем в текущий
dp 2. Проходимся циклом по dp для предыдущего символа. Например, в dp есть
значение 3, значит s[i - 3: i] - палиндром. Если текущий символ образует
с ним новый палиндром, то символ i - 4 должен быть равен текущему. То есть
для каждого значения в dp проводим сравнение символов i и i - dp[k] - 1,
при равенстве добавляем dp[k] + 2 в текущий dp. После прохода по dp делаем
его равным текущему dp, обновляем ответ при необходимости, сдвигаем указатель
и обновляем prev.

Лучшее решение: 199 ms, 18.19 Mb
"""


class Solution:

    def longestPalindrome(self, s: str) -> str:
        dp = [1]
        prev = s[0]
        ans = (1, 0)
        i = 1
        for letter in s[1:]:
            curr = [1]
            if letter == prev:
                curr.append(2)
            for e in dp:
                idx = i - e - 1
                if idx >= 0 and s[idx] == letter:
                    curr.append(e + 2)
            dp = curr
            if dp[-1] > ans[0]:
                ans = (dp[-1], i)
            i += 1
            prev = letter
        return s[ans[1] - ans[0] + 1: ans[1] + 1]
