"""
Find Trinagular Sum of an Array.

Дан набор целых чисел nums, каждый элемент которого находится в диапазоне
[0, 9]. Длина массива n. Происходит следующий процесс:
1. Если n > 1, то создается пустой массив newNums размера n - 1, иначе -
   процесс останавливается.
2. Для каждого индекса 0 <= i < n - 1 элемент newNums[i] определяется как
   (nums[i] + nums[i + 1]) % 10.
3. nums заменяется на newNums и процесс повторяется с шага 1.
Необходимо вернуть единственный элемент, оставшийся в nums после завершения
процесса.

Можно симулировать процесс и получить результат. Сложность такого решения
составит O(n ** 2), что при n <= 1000 приемлемо.

А можно обратиться к сути процесса. Каждый элемент нового массива является
суммой 2-х соседних элементов старого. Если идти к последнего полученного
массива к более старым, то каждый элемент можно вывести как некоторую
комбинацию исходных цифр. Ответ также выражается через набор изначальных
данных.

Остается вопрос с коэффициентами. Если выписать разложение для некоторых
размеров массива, то получим последовательность: [1], [1, 1], [1, 2, 1],
[1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1] и т.д. При записи друг под
другом можно заметить, что это треугольник Паскаля, значения в каждом ряду
которого являются биномиальными коэффициентами.

То есть необходимо найти сумму произведений элментов исходного массива на
биномиальные коэффициенты, соответствующие их позиции (номер ряда равен n - 1),
и взять последнюю цифру. Коэффициенты можно считать через факториалы, но это
долго, поэтому используем формулу (n, k) = (n, k - 1) * (n + 1 - k) // k.
То есть считаем текущий коэффициент через предыдущий. В ответе всегда храним
только последнюю цифру, но с коэффициентами это не работает. Python может
работать с такими числами, хотя это требует больше памяти. Такой подход
дает многократное ускорение (1187 ms при симуляции процесса).

Лучшее решение: 17 ms, 18.03 Mb
#math #combinatorics
"""


class Solution:

    def triangularSum(self, nums: list[int]) -> int:
        n = len(nums)
        curr = 1
        ans = nums[0]
        for i in range(1, n):
            curr = curr * (n - i) // i
            ans = (ans + (curr * nums[i]) % 10) % 10
        return ans
