"""
Minimum Removals to Balance Array.

Дан массив целых положительных чисел. Массив считается сбалансированным, если
его максимальное значение превосходит минимальное не больше, чем в k раз.
Найти наименьшее количество элементов, которые нужно удалить, чтобы массив
стал сбалансированным.

Используем сортировку и метод двух указателей. Общая идея в том, что для
каждого положения левого указателя находим первый элемент, который нарушает
условие сбалансированности, то есть nums[right] > nums[left] * k. Тогда для
балансировки массива необходимо удалить left первых элементов и n - right
последних. При сдвиге левого указателя вправо на 1, right также будет
двигаться только вправо, так как все числа левее подходили под условие баланса
еще при меньшем значении nums[left]. Таким образом, указатели проходят по
массиву только 1 раз, что дает линейную сложность для получения текущих
значений ответа (хотя общая сложность O(NlogN) за счет сортировки).

Изначально оба указателя стоят в начале массива. Сдвигаем правый указатель от
его текущего положения, пока nums[right] <= nums[left] * k. Сравниваем ответ
для полученного положения указателей, left + n - right, с ans и обновляем
ans при необходимости. Сдвигаем left на 1 вправо. Продолжаем цикл, пока правый
указатель не дойдет до конца массива. Дальше нет смысла двигать левый
указатель, так как количество удаляемых элементов при таком сдвиге будет
только расти.

Лучшее решение: 108 ms, 34.67 Mb
#sorting #two_pointers #array
"""


class Solution:

    def minRemoval(self, nums: list[int], k: int) -> int:
        nums.sort()
        ans = float('inf')
        left = right = 0
        n = len(nums)
        while right < n:
            comp = nums[left] * k
            while right < n and nums[right] <= comp:
                right += 1
            ans = min(ans, left + n - right)
            left += 1
        return ans
