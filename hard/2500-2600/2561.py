"""
Rearranging Fruits.

Даны 2 массива целых чисел basket1 и basket2 одинаковой длины. К массивам
неограниченное количество раз можно применить операцию swap и поменять
любые 2 значения. Стоимость такой операции равна меньшему элементу в паре.
Необходимо найти минимальную суммарную стоимость, за которую можно сделать
массивы одинаковыми, то есть состоящими из одинаковых чисел, расположенных
в любом порядке, или вернуть -1, если это невозможно.

Для каждого массива посчитаем кол-во вхождений каждого элемента в нем,
это словари d1 и d2. Теперь нужно определить, какие элементы нужно перебросить
из каждого массива, чтобы сделать их одинаковыми. В массивах b1 и b2 будем
хранить элементы, которые нужно обменять из 1 и 2 массива соответственно.

Сначала проходимся по ключам d1. Если этот ключ есть и в d2, то берем его
значение, иначе - 0. Если суммарная частота элемента нечетная, то разделить
его поровну между двумя массивами нельзя, поэтому возвращаем -1. В ином
случае определяем сколько вхождений ключа должно быть в каждом массиве (half).
Если в массиве 1 вхождений больше, чем нужно, то добавляем в b1 текущий ключ
d1[k] - half раз. Аналогично для второго массива. Затем удаляем этот ключ
из словаря d2, если он есть.

Затем проходимся по словарю d2. После предыдущего цикла в нем остались только
ключи, которых нет в d1. Для них просто проверяем четность числа вхождений
и добавляем нужное число повторений ключа в b2.

Теперь мы знаем, какие элементы нужно обменять. Исходные размеры массивов
равны, поэтому и размеры b1 и b2 тоже совпадают. Так как необходимо
минимизировать общую стоимость, то логично обменивать дешевый элемент с
дорогим. Поэтому отсортируем b1 в порядке возрастания, b2 - в порядке
убывания, а затем сформируем пары. Однако нужно учесть еще один вариант.
Количество обменов не ограничено, поэтому вместо того, чтобы сразу менять
элементы друг с другом можно каждый поочередно обменять с самым маленьким
элементом в массивах (min_val). Таким образом, стоимость обмена будет равна
минимуму из 2 * min_val, min(b1[i], b2[i]). Эти значения нужно суммировать
для ответа.

Лучшее решение: 59 ms, 39.82 Mb
"""


from collections import Counter


class Solution:

    def minCost2(self, basket1: list[int], basket2: list[int]) -> int:
        d1 = Counter(basket1)
        d2 = Counter(basket2)
        b1 = []
        b2 = []
        for k, v in d1.items():
            v2 = d2.get(k, 0)
            if (v + v2) % 2:
                return -1
            half = (v + v2) // 2
            if v > half:
                b1.extend([k] * (v - half))
            elif v2 > half:
                b2.extend([k] * (v2 - half))
            d2.pop(k, None)
        for k, v in d2.items():
            if v % 2:
                return -1
            b2.extend([k] * (v // 2))
        min_val = min(min(basket1), min(basket2))
        return sum(
            map(
                lambda e: min(2 * min_val, min(e)),
                zip(sorted(b1), sorted(b2, reverse=True))
            )
        )
