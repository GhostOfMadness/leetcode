"""
Maximum Side Length of a Square with Sum Less than or Equal to Threshold.

Дана матрица целых неотрицательных чисел размера m * n. Найти наибольшую
сторону квадрата, сумма чисел в котором не превосходит заданный порог.

Вне зависимости от подхода сначала нужно посчитать префиксные суммы и
определить функцию проверки квадрата. Префиксы сохраняем в rect, rect[i][j]
- сумма чисел в прямоугольнике, левый верхний угол которого нахолится в (0, 0),
а правый нижний - в (i, j). Для удобства заполнения матрица rect имеет размер
(m + 1) * (n + 1), поэтому индексы в ней сдвинуты на +1 относительно исходной
матрицы значений. Теперь функция проверки суммы квадрата. Пусть имеется
квадрат, верхний левый угол которого находится в точке (i, j), а длина стороны
равна k. Этот квадрат входит во внешний квадрат от (0, 0) до
(i + k - 1, j + k - 1). Отрезаем от него прямоугольник от (0, 0) до
(i + k - 1, j - 1) и прямоугольник от (0, 0) до (i - 1, j + k - 1). Эти
прямоугольники пересекаются, площадь пересечения составляет квадрат от (0, 0)
до (i - 1, j - 1), который вычитается дважды, поэтому прибавляем его площадь.
Так получаем сумму чисел в произвольном квадрате.

Далее можно идти несколькими путями. Все числа в матрице неотрицательные,
значит с увеличением размера квадрата сумма чисел в нем не уменьшается.
Следовательно, можно использовать бинарный поиск. Можно перебирать все левые
углы квадратов и для каждого запускать поиск для стороны от текущего максимума
до потенциально возможного максимума для этих координат. А можно во внешнем
цикле перебирать варианты сторон и на каждом шаге поиска проводить проверку
по всем квадратам. Если сумма чисел хотя бы в одном квадрате меньше порога,
то сдвигаем левую границу поиска, иначе - правую. Второй вариант работает
быстрее.

Можно обойтись без бинарного поиска. Перебираем все возможные начальные точки
квадратов и для каждой точки линейно подбираем наибольший размер от текущего
максимума + 1 до потенциально возможного значения. Если проверка пройдена,
то заносим текущую сторону в ответ, иначе - прерываем цикл и переходим к
следующей точке. Это самый быстрый вариант. В бинарном поиске при сдвиге
левой границы проверяются и квадраты, которые и раньше не подходили под порог,
что увеличивает количество действий.

Лучшее решение: 153 ms, 25.66 Mb
#matrix #prefix_sum #binary_search
"""


class Solution:

    def maxSideLengthBinSearch(
        self,
        mat: list[list[int]],
        threshold: int,
    ) -> int:
        """327 ms, 26.05 Mb."""
        m, n = len(mat), len(mat[0])
        rect = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                rect[i][j] = (
                    rect[i - 1][j]
                    + rect[i][j - 1]
                    - rect[i - 1][j - 1]
                    + mat[i - 1][j - 1]
                )

        def checkSquare(i, j, k):
            s = (
                rect[i + k][j + k]
                - rect[i + k][j]
                - rect[i][j + k]
                + rect[i][j]
            )
            return s <= threshold

        left, right = 0, min(m, n) + 1
        while left < right:
            mid = (left + right) // 2
            curr = any(
                checkSquare(i, j, mid)
                for i in range(m - mid + 1)
                for j in range(n - mid + 1)
            )
            if curr:
                left = mid + 1
            else:
                right = mid
        return left - 1

    def maxSideLengthEarlyStop(
        self,
        mat: list[list[int]],
        threshold: int,
    ) -> int:
        """153 ms, 25.66 Mb."""
        m, n = len(mat), len(mat[0])
        rect = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                rect[i][j] = (
                    rect[i - 1][j]
                    + rect[i][j - 1]
                    - rect[i - 1][j - 1]
                    + mat[i - 1][j - 1]
                )

        def checkSquare(i, j, k):
            s = (
                rect[i + k][j + k]
                - rect[i + k][j]
                - rect[i][j + k]
                + rect[i][j]
            )
            return s <= threshold

        ans = 0
        for i in range(m):
            for j in range(n):
                max_k = min(m - i, n - j) + 1
                if i < m - ans and j < n - ans:
                    for k in range(ans + 1, max_k):
                        if checkSquare(i, j, k):
                            ans = k
                        else:
                            break
        return ans
