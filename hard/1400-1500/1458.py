"""
Max Dot Product of Two Subsequences.

Даны 2 массива целых чисел. Найти наибольшее скалярное произведение, которое
можно получить из подмассивов исходных массивов. Подмассив получается путем
вычеркивания нескольких (возможно нуля) значений из исходного массива, не
меняя их порядок.

Используем динамическое программирование. Строки задают числа из nums2,
столбцы - числа из nums1. dp[i][j] - максимальный скаляр, который можно
получить используя от 1 до i чисел из nums2 и от 1 до j чисел из nums1.

Пусть мы используем i-е число из nums2 и j-е число из nums1. Скаляр точно
содержит их произведение. Кроме того, в ответ можно включить и лучшую
комбинацию из чисел nums2 до позиции i и чисел nums1 до позиции j. Эту
величину стоит прибавлять, если она положительна, ведь иначе выгоднее просто
не включать предыдущие числа в подмассивы. Таким образом, при использовании
i-го и j-го чисел из nums2 и nums1 оптимальным ответом будет
nums2[i] * nums1[j] + max(0, dp[i - 1][j - 1]) = include.

Но каждое из этих чисел можно и не включать в ответ. Если не включаем i-е
число nums2, то лучшим ответом будет dp[i - 1][j], без j-го числа nums1 -
dp[i][j - 1]. То есть, dp[i][j] = max(include, dp[i - 1][j], dp[i][j - 1]).

Можно заметить, что на каждом шаге используется только текущая и предыдущая
строки матрицы dp, значит можно не хранить ее полностью, а поддерживать
только текущие значения. dp - предыдущая строка, row - текущая строка.
Длины строк увеличены на 1 относительно длины nums1, чтобы не обрабатывать
первое значение отдельно. row[j] равно максимуму из row[j - 1] (комбинация
без j-го числа nums1), dp[j] (комбинация без i-го числа nums2) и
nums1[j - 1] * nums2[i] + max(0, dp[j - 1]) (включение обоих чисел).

Лучшее решение: 95 ms, 19.23 Mb
#dynamic_programming #array
"""


class Solution:

    def maxDotProduct(self, nums1: list[int], nums2: list[int]) -> int:
        """95 ms, 19.23 Mb"""
        len1, len2 = len(nums1), len(nums2)
        dp = [float('-inf')] * (len1 + 1)
        for i in range(len2):
            row = [float('-inf')] * (len1 + 1)
            for j in range(1, len1 + 1):
                row[j] = max(
                    row[j - 1],
                    dp[j],
                    nums1[j - 1] * nums2[i] + max(0, dp[j - 1]),
                )
            dp = row
            del row
        return dp[len1]
