"""
Triangle.

Дан двумерный массив, задающий треугольник. Необходимо найти сумму
минимального пути от вершины к основанию. Двигаться можно только к соседнему
элементу на следующей строчке, то есть от triangle[i][j] можно перейти к
triangle[i + 1][j] или triangle[i + 1][j + 1].

Можно идти от вершины и использовать рекурсию, прибавляя к текущему значению
ответ от треугольника меньшего размера (если треугольник состоит из одного
элемента, то ответом будет он сам). А можно сделать это итеративно, двигаясь
снизу вверх и используя динамическое программирование.

При втором подходе на каждом шаге достаточно знать ответ только для
предыдущего шага. Если треугольник состоит из одного элемента, то ответом
будет этот элемент, значит последняя строка будет ответом для себя. Заносим
ее в prev (эта строка будет всегда, потому что размер треугольника не меньше
1). На каждой итерации цикла переходим к строке выше и перезаписываем prev.
Проходимся по элементам исходной строки (их i + 1), к каждому прибавляем
минимум из соседних результатов с предыдущего шага (prev[j] или prev[j + 1])
и заносим их в prev слева направо. После прохождения цикла 0-м элементом prev
будет искомая сумма (это же случится, если размер треугольника равен 1 и цикл
вовсе не запускался). Можно собирать результат итерации в отдельный массив,
а затем перекидывать ссылку prev на него, но это требует больше времени.
В текущем подходе в prev сохраняются и ненужные значения, но так как в
треугольнике не больше 200 уровней, то это не сильно нагружает память.

Лучшее решение: 0 ms, 18.58 Mb
#dynamic_programming #array
"""


class Solution:

    def minimumTotal(self, triangle: list[list[int]]) -> int:
        n = len(triangle)
        prev = triangle[n - 1]
        for i in range(n - 2, -1, -1):
            for j in range(i + 1):
                add = prev[j] if prev[j] < prev[j + 1] else prev[j + 1]
                prev[j] = triangle[i][j] + add
        return prev[0]
