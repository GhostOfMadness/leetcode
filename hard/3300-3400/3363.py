"""
Find the Maximum Number of Fruits Collected.

Дана квадратная матрица fruits размера n, где fruits[i][j] - кол-во фруктов
в комнате с координатами (i, j). Игроки находятся в правом верхнем и нижнем
углу, а также в левом верхнем углу. Они могут двигаться по следующим правилам:
- (0, 0): (i, j + 1), (i + 1, j), (i + 1, j + 1)
- (n - 1, 0): (i - 1, j + 1), (i, j + 1), (i + 1, j + 1)
- (0, n - 1): (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)
Каждый игрок должен дойти до клетки (n - 1, n - 1) за n - 1 шагов. Найти
максимальное количество фруктов, которые они могут собрать по пути.

Игрок, стоящий в клетке (0, 0), может двигаться только по диагонали i = j,
чтобы достичь цели за n - 1 ход. То есть ответом для него будет сумма
элементов на диагонали. Оставшиеся 2 игрока могут менять направление движения.
Однако их области движения ограничены в рамках диагоналей i = j
и i + j = n - 1, чтобы цель была достижима за n - 1 шаг. При этом им нет
смысла заходить на диагональ i = j, потому что фрукты там уже были собраны
игроком 1.

Используем метод динамического программирования. В качестве массива для
накопления результата воспользуемся исходной матрицей. Для игрока 2 будем
проходить слева направа и снизу вверх, для игрока 3 = сверху вниз и справа
налево. Идти будет не до (n - 1, n - 1), а до (n - 1, n - 2) и (n - 2, n - 1).

Для игрока 2 координата first - столбец, для игрока 3 - строка. Диапазон
изменения от 1, так как стартуем из 0, до n - 1, так как идем не до последнего
элемента. Координата second должна лежать в пределах 2-х диагоналей, то есть
она больше first и больше n - 2 - first (-2, т.к. диагональ i + j = n - 1
входит в диапазон рассмотрения), то есть меняется от n - 1 до максимума из
этих значений.

Массив shifts задает варианты смены направления второй координаты. Если вторая
координата находится в пределах массива и в пределах области движения, то
заносим ее в массив to_add. В итоге to_add будет хранить ответ для соседей,
из которых можно попасть в текущую вершину. Выбираем максимум и прибавляем его
к имеющемуся значению.

Общий ответ формируется как сумма элементов на диагонали i = j, с добавлением
элементов на позициях n - 1, n - 2) и (n - 2, n - 1).

Лучшее решение: 893 ms, 96.35 Mb
"""


class Solution:

    def __dp(
        self,
        fruits: list[list[int]],
        n: int,
        is_first_col: bool = True,
    ) -> None:
        for first in range(1, n - 1):
            for second in range(n - 1, max(first, n - 2 - first), -1):
                shifts = [-1, 0, 1]
                to_add = [0, 0, 0]
                for k in range(3):
                    new_second = second + shifts[k]
                    if n - first - 1 < new_second < n:
                        if is_first_col:
                            to_add[k] = fruits[new_second][first - 1]
                        else:
                            to_add[k] = fruits[first - 1][new_second]
                if is_first_col:
                    fruits[second][first] += max(to_add)
                else:
                    fruits[first][second] += max(to_add)

    def maxCollectedFruits(self, fruits: list[list[int]]) -> int:
        n = len(fruits)
        ans = sum(fruits[i][i] for i in range(n))
        self.__dp(fruits=fruits, n=n)
        ans += fruits[n - 1][n - 2]
        self.__dp(fruits=fruits, n=n, is_first_col=False)
        ans += fruits[n - 2][n - 1]
        return ans


if __name__ == '__main__':
    res = Solution()
    # fruits = [
    #     [1, 2, 3, 4, 5],
    #     [7, 9, 8, 6, 10],
    #     [15, 11, 14, 12, 13],
    #     [17, 20, 19, 18, 16],
    #     [21, 22, 23, 24, 25],
    # ]
    # fruits = [[1, 1], [1, 1]]
    fruits = [
        [1, 2, 3, 4],
        [5, 6, 8, 7],
        [9, 10, 11, 12],
        [13, 14, 15, 16],
    ]
    res.maxCollectedFruits(fruits)
    for row in fruits:
        print(row)
