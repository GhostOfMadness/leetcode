"""
Construct Binary Tree from Preorder and Inorder Traversal.

Даны массивы preorder и inorder, содержащие порядок прохождения узлов при
прямом (preorder) и центрированном (inorder) обходах соответственно. На основе
этих данных необходимо восстановить исходное бинарное дерево.

При прямом обходе сначала записываем значение текущего узла, затем запускаем
рекурсию сначала для левого и правого поддеревьев (именно в таком порядке).
При центрированном обходе сначала запускаем рекурсию по левому поддереву,
затем записываем значение текущего узла, потом обходим правое поддерево.
Таким образом, первое значение в preorder - корень дерева, а первое значение
inorder - крайний левый элемент этого дерева.

Так как мы точно знаем значения корня дерева, то сразу создаем узел на его
основе и кладем его в стек. Устанавливаем указатели i и j на массивы preorder
и inorder (i = 1, т.к. первое значение уже использовано для корня). Также
создаем множество посещенных узлов visited (изначально пустое) и переменную
last (изначально None).

Внешний цикл работает, пока не будет выполнено условие остановки внутри него.
Внутри этого цикла последовательно реализуются 2 цикла while. Первый цикл
while идет по preorder и заполняет стек, пока preorder[i - 1] != inorder[j].
Используем i - 1, чтобы в стек попало и первое совпадение значений. Оба
обхода предполагают рекурсию сначала по левому дереву, только при прямом
обходе перед этим записывается значение текущего узла. Следовательно, если мы
идем по preorder, а текущее значение не совпадает с inorder[j], то мы не дошли
до самого левого элемента текущего поддерева. На каждой итерации этого цикла
создаем новый узел из текущего значения и добавляем его к родителю, который
всегда лежит на вершине стека. Если родительский узел уже был посещен, то
его левое поддерево (если оно предполагалось) уже сформировано, поэтому новый
узел добавляем справа (проверка нужна при первой итерации цикла). В ином
случае, добавлем узел слева. Кладем узел в стек и переходим у следующей
проверке. Далее проверяем условие остановки - индекс i дошел до конца массива
preorder. Если условие остановки не выполнено, то запускается второй цикл
while, который удаляет элементы с вершины стека. Удаление происходит, если
значение узла на вершине равно inorder[j] (то есть теперь движемся от крайнего
левого элемента в обратном направлении) или узел уже был посещен (если
посещенный узел оказался в стеке на данном этапе, то у него уже заполено и
левое, и правое поддерево). В первом случае сохраняем удаляемый узел в
переменную last, помечаем его посещенным и сдвигаем индекс j на 1 вправо.
Если равенство stack[-1] == inorder[j] перестало выполняться, то дл] узла
last левое дерево определено, поэтому далее движемся от него вправо. Заносим
last в стек и переходим к началу внешнего цикла.

Лучшее решение: 1 ms, 20.27 Mb
#binary_tree #stack #dfs
"""


class TreeNode:

    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:

    def buildTree(self, preorder: list[int], inorder: list[int]) -> TreeNode:
        root = TreeNode(val=preorder[0])
        stack: list[TreeNode] = [root]
        i, j = 1, 0
        length = len(preorder)
        visited: set[TreeNode] = set()
        last = None
        while True:
            while i < length and preorder[i - 1] != inorder[j]:
                node = TreeNode(val=preorder[i])
                parent = stack[-1]
                if parent in visited:
                    parent.right = node
                else:
                    parent.left = node
                stack.append(node)
                i += 1
            if i == length:
                break
            while stack:
                if stack[-1].val == inorder[j]:
                    last = stack.pop()
                    visited.add(last)
                    j += 1
                elif stack[-1] in visited:
                    stack.pop()
                else:
                    break
            stack.append(last)
        return root
