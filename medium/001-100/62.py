"""
Unique Paths.

Дано игровое поле размером m * n. Изначално робот находится в верхнем левом
углу. Необходимо найти количество уникальных путей до нижнего правого угла
при условии, что робот может ходить только вниз или вправо.

Используем динамическое программирование. В каждую клетку можно попасть либо
сверху, либо слева, значит dp[i][j] = dp[i][j - 1] + dp[i - 1][j]. Также
из этого следует, что достаточно знать ответы для предыдущей строки, вся
матрица dp не нужна.

Лучшее решение: 0 ms, 17.94 Mb
"""
from itertools import accumulate


class Solution:

    def uniquePaths(self, m: int, n: int) -> int:
        dp = [1] * n
        for _ in range(1, m):
            dp = list(accumulate(dp))
        return dp[n - 1]
