"""
House Robber II.

Дан массив nums, представляющий собой количество денег в каждом из домов на
улице. Найти наибоьшую сумму денег, которую может украсть грабитель, если
ему нельзя заходить в соседние дома от ограбленного. При этом дома расположены
в круг, то есть последний дом является соседом для первого.

Используем динамическое программирование. dp[i] = max(dp[:i-1]) + nums[i],
то есть количеству денег в текущем доме и лучшей комбинации домов, которые
не являются соседними. Для домов 0 и 1 ответом будут их значения из nums.
Такой способ подходит для всех домов, кроме последнего, так лучшая из прошлых
комбинаций может включать дом 0, который для него является соседним. Поэтому
на данном шаге сохраняем ответ для домов [0, n - 1). Для последнего дома
запускаем этот же цикл, только для дома 0 ставим не его значение из nums, а
ноль, то есть ищем лучшие комбинации, игнорируя дом 0. Тогда конечным ответом
будет максимум из уже найденного ответа для домов [0, n - 1) и полученного
ответа для последнего дома.

Лучшее решение: 0 ms, 17.73 Mb
"""


class Solution:

    def rob(self, nums: list[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        dp = [0] * n
        dp[0] = nums[0]
        dp[1] = nums[1]
        for i in range(2, n - 1):
            dp[i] = nums[i] + max(dp[:i-1])
        ans = max(dp)
        dp[0] = 0
        dp[1] = nums[1]
        for i in range(2, n):
            dp[i] = nums[i] + max(dp[:i-1])
        return max(ans, dp[n - 1])


if __name__ == '__main__':
    res = Solution()
    nums = [2, 3, 2]
    print(res.rob(nums))
