"""
Valid Triangle Number.

Дан массив целых чисел. Найти количество треугольников, которые можно получить,
используя любые 3 числа из массива.

В треугольнике длина каждой стороны меньше суммы двух других. В триплете
достаточно проверить, что самая большая сторона удовлетворяет этому условию.
Поэтому сначала отсортируем массив по возрастанию, а дальше есть несколько
подходов.

Первый способ имеет сложность O(n ** 2 * log(n)). Перебираем все пары массива
и с помощью бинарного поиска ищем индекс 1-го элемента, который больше или
равен сумме элементов в паре. Все индексы между найденным и вторым из пары
подходят для формирования треугольника, заносим их количество в ответ. При
этом найденный индекс может двигаться только вправо относительно внутреннего
цикла, так как с ростом j увеличивается и сумма. Поэтому для последующих j
можно запускать поиск от max(j + 1, найденный idx). Второй способ использует
эту же идею, только вместо бинарного поиска индекс сдвигается линейно во
внутреннем цикле, обеспечивая сложность O(n ** 2). Если индекс уже дошел до
конца массива, то выходим из внутреннего цикла и к ответу добавляем сумму
первых n - j - 2 чисел натурального ряда.

Третий способ использует 2 указателя. Идем по массиву справа налево и
фиксируем самую большую сторону. Левый указатель ставим в начало массива,
а правый - на i - 1. Правый указатель фиксирует вторую сторону. Если сумма
чисел под указателями больше самой большой стороны, то в пару к текущему
элементу под right подойдут все числа от left до right - 1, так как сумма
только увеличивается при движении направо. Добавляем это числа в ответ
и сдвигаем right на 1 влево. Если сумма меньше или равна, то сдвигаем left
вправо и повторяем проверку. Продолжаем, пока left < right.

Лучшее решение 1: 2391 ms, 17.56 Mb
Лучшее решение 2: 663 ms, 17.76 Mb
Лучшее решение 3: 401 ms, 18.00 Mb
#two_pointers #array #sorting
"""


class Solution:

    def triangleNumber(self, nums: list[int]) -> int:
        n = len(nums)
        nums.sort()

        def binsearch(left, target):
            right = n
            mid = (left + right) // 2
            while left < right:
                if nums[mid] >= target:
                    right = mid
                else:
                    left = mid + 1
                mid = (left + right) // 2
            return right

        ans = 0
        for i in range(n - 2):
            idx = i + 2
            for j in range(i + 1, n - 1):
                if idx < j + 1:
                    idx = j + 1
                idx = binsearch(left=idx, target=nums[i] + nums[j])
                ans += idx - 1 - j
        return ans

    def triangleNumber2(self, nums: list[int]) -> int:
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n - 2):
            idx = i + 2
            for j in range(i + 1, n - 1):
                if idx < j + 1:
                    idx = j + 1
                while idx < n and nums[idx] < nums[i] + nums[j]:
                    idx += 1
                ans += idx - 1 - j
                if idx == n:
                    break
            curr = n - j - 2
            ans += curr * (curr + 1) // 2
        return ans

    def triangleNumber3(self, nums: list[int]) -> int:
        n = len(nums)
        nums.sort()
        ans = 0
        for i in range(n - 1, 1, -1):
            left, right = 0, i - 1
            target = nums[i]
            while left < right:
                if nums[right] + nums[left] > target:
                    ans += right - left
                    right -= 1
                else:
                    left += 1
        return ans
