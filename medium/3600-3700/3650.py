"""
Minimum Cost Path with Edge Reversals.

Дан ориентированный граф из n вершин, пронумерованных числами от 0 до n - 1.
Какое-то одно ребро от каждой вершины можно развернуть, увеличивая вес этого
ребра в 2 раза. Найти минимальную стоимость пути из вершины 0 в вершину n - 1.

Возможность разворота ребра по сути превращает граф в неориентированный.
Создаем список смежности g, в котором i - номер вершины, g[i] - список ребер
и их весов, ведущих из вершины i. Каждое ребро заносится в вершину начала
с исходным весом и в вершину конца с удвоенным весом.

Далее используем алгоритм Дейкстры для поиска кратчайшего пути, так как по
условию все веса положительные. Заводим массив dist для хранения найденных
расстояний от вершины 0 и двоичную мин-кучу heap для поиска непосещенной
вершины с минимальным расстоянием. Снимаем очередной узел с вершины кучи
и обновляем расстояния для всех его непомещенных соседей. Затем помечаем узел
посещенным, то есть в списке g ставим у него None. Цикл идет, пока минимальным
расстоянием не окажется бесконечность (то есть до вершины n - 1 нельзя дойти)
или пока не снимем узел n - 1 (узлы после него можно не рассматривать, так
как пути от них заведомо больше).

Куча позволяет быстро извлекать минимум и добавлять новое значение, но не
обновлять произвольный элемент. Поэтому при обновлении расстояния до вершины
просто кладем новое в кучу, не удаляя старое. А когда снимаем элемент с
вершины кучи, то проверяем, что он еще не посещен. То есть снимаем элементы,
пока не найдем первый не посещенный узел. Такой подход увеличивает расход
памяти относительно одного массива dist, но заметно ускоряет поиск минимума,
так как не нужно линейно проходить по массиву dist на каждой новой вершине.

Лучшее решение: 550 ms, 73.30 Mb
#graph_theory #heap #shortest_path
"""
import heapq
import math


class Solution:

    def minCost(self, n: int, edges: list[list[int]]) -> int:
        g = [[] for _ in range(n)]
        for start, end, weight in edges:
            g[start].append((end, weight))
            g[end].append((start, weight * 2))
        dist = [float('inf')] * n
        dist[0] = 0
        heap = [(float('inf'), i) for i in range(n)]
        heap[0] = (0, 0)
        heapq.heapify(heap)
        while True:
            curr = heapq.heappop(heap)
            while g[curr[1]] is None:
                curr = heapq.heappop(heap)
            d, node = curr
            if math.isinf(d):
                return -1
            if node == n - 1:
                return d
            for nnode, nweight in g[node]:
                if g[nnode]:
                    val = d + nweight
                    if val < dist[nnode]:
                        dist[nnode] = val
                        heapq.heappush(heap, (val, nnode))
            g[node] = None
