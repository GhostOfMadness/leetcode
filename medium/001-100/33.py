"""
Search in Rotated Sorted Array.

Дан отсортированный по возрастанию массив целых чисел, который возможно был
сдвинут на несколько позиций влево. Например, массив [0, 1, 2, 4, 5, 6, 7]
может быть сдвинут на 3 влево, тогда он будет равен [4, 5, 6, 7, 0, 1, 2].
Также задано целое число. Определить индекс этого числа в массиве или вернуть
-1, если его нет.

Массив отсортирован, поэтому используем бинарный поиск. Одним проходом можно
найти позицию минимума в массиве, а вторым - запустить стандартный поиск
по отсортированным частям массива. А можно объединить эти шаги для ускорения
работы. Основной бинарный поиск будет искать минимальное значение и запускать
классический бинарный поиск для найденных границ отсортированных участков,
если target находится между ними.

Левая и правая границы поиска равны 0 и длине массива соответственно. Ведем
поиск, пока левая граница меньше правой. Сначала находим середину отрезка mid.
Если nums[mid] == target, то поиск окончен. В ином случае, сравниваем
элемент в середине с началом массива. Если nums[mid] > nums[0], то минимум
массива точно находится правее mid, а nums[:mid + 1] представляет собой
отсортированный участок. Если nums[0] <= target < nums[mid], то запускаем
обычный бинарный поиск на этом участке и возвращаем ответ. Если target не
лежит в этих границах, то сдвигаем левую границу на mid + 1 и продолжаем
поиск минимума. Если же nums[mid] < nums[0], то минимум лежит левее, а
часть массива правее отсортирована. Если target находится в границах от
nums[mid] + 1 до nums[-1], то запускаем стандартный бинарный поиск на этой
части массива. Если нет, то сдвигаем правую границу на mid. Если в процессе
поиска минимума классический бинарный поиск так и не был запущен, то элемента
в массиве нет, поэтому возращаем -1.

Лучшее решение: 0 ms, 19.34 Mb
#binary_search #array
"""


class Solution:

    def binsearch(
        self,
        nums: list[int],
        target: int,
        left: int,
        right: int,
    ) -> int:
        while left < right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        return -1

    def search(self, nums: list[int], target: int) -> int:
        length = len(nums)
        left, right = 0, length
        comp = nums[0]
        while left < right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            if nums[mid] > comp:
                if comp <= target < nums[mid]:
                    return self.binsearch(nums, target, 0, mid)
                left = mid + 1
            else:
                if nums[mid] < target <= nums[-1]:
                    return self.binsearch(nums, target, mid + 1, length)
                right = mid
        return - 1
