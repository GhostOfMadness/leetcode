"""
Word Break.

Дана строка, состоящая из строчных латинских букв, и словарь, представляющий
собой список слов. Определить, можно ли разбить строку по словам словаря.
Каждое слово можно использовать несколько раз.

Используем динамическое программирование. dp[i] - булево значение, которое
определяет, можно ли представить префикс s[:i + 1] как набор слов из словаря.

Простым вариантом будет перебирать все символы слева направо и проверять
префиксы от позиций True в dp до текущего символа. Например, s = 'catdog',
wordDict = ['cat', 'dog']. dp имеет размер на 1 больше, чем длина строки,
и первым значением будет True, чтобы идти до начала строки. Идем по строке:
- 'c': 'c' нет в словаре, dp[1] = False
- 'a': 'a', 'ca' нет в словаре, dp[2] = False
- 't': 't', 'at' нет в словаре, но есть 'cat', dp[3] = True
- 'd': 'd', 'catd' нет в словаре, dp[4] = False
- 'o': 'do', 'catdo' нет в словаре, dp[5] = False
- 'g': 'dog' есть в словаре, dp[6] = True
dp[-1] = True, значит строку можно разбить на слова. Этот подход является
простым в реализации, но медленным, так как необходимо извлекать много
подстрок или использовать конкатенацию на каждом шаге.

Более бычтрый вариант состоит из 2-х этапов. Сначала строим префиксное дерево
(trie) на основе исходного списка слов. Затем также срздаем одномерный массив
dp длины s.length + 1. Однако в данном случае движемся слева направо. Идея в
том, чтобы от конца найденного слова (т.е. dp[i] = True) двигаться вправо,
добавляя по 1 символу, пока такой префикс есть в trie, и помечать найденные
слова. Затем переходить к следующей пометке и повторять процесс. То есть
внешний цикл проходит по dp, внутренний цикл запускается, если нашли конец
слова. Во внутреннем цикле берем следующую букву слова и начинаем спуск от
корня дерева. Если этой буквы там нет, то выходим из цикла. Если буква есть
то переносим корень на эту букву и берем следующую. А если на ней
заканчивается слово, то ставим True на соответствующем месте dp. Если на
последнем месте в dp будет True, то строка разбивается по словам.

Лучшее решение: 0 ms, 20.77 Mb
#dynamic_programming #trie #string
"""


class Solution:

    def wordBreak(self, s: str, wordDict: list[str]) -> bool:
        trie = {'': [{}, False]}
        for word in wordDict:
            root = trie['']
            for letter in word:
                if letter not in root[0]:
                    root[0][letter] = [{}, False]
                root = root[0][letter]
            root[1] = True
        length = len(s)
        dp = [False] * (length + 1)
        dp[0] = True
        for i in range(length):
            if dp[i]:
                root = trie[''][0]
                for j in range(i, length):
                    letter = s[j]
                    if letter not in root:
                        break
                    dp[j + 1] = any([dp[j + 1], root[letter][1]])
                    root = root[letter][0]
        return dp[length]
