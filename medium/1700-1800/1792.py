"""
Maximum Average Pass Ratio.

Дан двумерный массив classes, где classes[0] - кол-во студентов класса,
которые сдадут экзамен, classes[1] - общее кол-во студентов в классе.
Также есть extraStudents учеников, которые точно сдадут экзамен, но еще
не распределены по классам. Рейтинг класса определяется как доля студентов,
успешно сдавших экзамен. Общий рейтинг считается как среднее от рейтингов
класса. Найти максимальное значение общего рейтинга после распределения
всех extraStudents.

Логично добавлять каждого свободного студента в класс, где такое увеличение
даст максимальный прирост рейтинга. Пусть в классе y студентов, из которых
x сдадут экзамен, то есть рейтинг равен x / y. После добавления студента
в этот класс его рейтинг изменится на (x + 1) / (y + 1). Прибавка составит
(x + 1) / (y + 1) - x / y = (y - x) / (y * (y + 1)). То есть на каждом шаге
выбираем класс с наибольшей прибавкой. Для этого будем хранить классы в
бинарной куче, для сравнения используя как раз величину прибавки со знаком
минус. Тогда нужный класс всегда будет на вершине. Обновляем для него значения
числителя и знаменателя, пересчитываем его прибавку и снова кладем в кучу.

Лучшее решение: 1177 ms, 54.81 Mb
#heap #greedy
"""
import heapq


class Solution:

    def maxAverageRatio(
        self,
        classes: list[list[int]],
        extraStudents: int,
    ) -> float:
        def get_ratio(x, y):
            return -(y - x) / (y * (y + 1))

        h = [
            [get_ratio(num, den), num, den]
            for num, den in classes
        ]
        heapq.heapify(h)
        for _ in range(extraStudents):
            ratio, num, den = h[0]
            num += 1
            den += 1
            heapq.heapreplace(h, [get_ratio(num, den), num, den])
        ans = sum(e[1] / e[2] for e in h) / len(h)
        return round(ans, 5)
