"""
Coin Change.

Определить наименьшее количество монет из массива coins, необходимое для
получения заданной суммы amount. Если сумма недостижима, то вернуть -1.
Количество монет каждого номинала неограничено.

Задача похожа на классическую задачу о рюкзаке, только каждый предмет можно
использовать любое количество раз, но смысл одинаков. Создаем массив dp от 0
до amount включительно и заполняем его -1. Первое значение ставим на ноль,
так как для получения нуля монеты не нужны. Проходимся по каждому номиналу
coin в массиве coins. Внутренний цикл идет от начала массива до amount - coin
включительно. Идем именно слева направо, чтобы учесть неоднократное
использование текущего номинала монеты (главное отличие от задачи о рюкзаке,
где такого как раз нужно избегать). Если dp[i] != -1, то есть i-ю сумму можно
получить, то смотрим на dp[i + coin]. Если там стоит -1, то есть сумма ранее
не достигалась, или значение там больше, чем dp[i] + 1 (+ 1 за добавление
одной монеты coin), то обновляем dp[i + coin] на dp[i] + 1. Ответ на задачу
будет в dp[amount]. Если там так и останется -1, то сумма недостижима, иначе
- возвращаем найденное минимальное количество монет.

Лучшее решение: 371 ms, 19.59 Mb
#dynamic_programming #array
"""


class Solution:

    def coinChange(self, coins: list[int], amount: int) -> int:
        dp = [-1] * (amount + 1)
        dp[0] = 0
        for coin in coins:
            for i in range(amount - coin + 1):
                if dp[i] != -1:
                    if dp[i + coin] == -1 or dp[i + coin] > dp[i] + 1:
                        dp[i + coin] = dp[i] + 1
        return dp[amount]
