"""
Partition Labels.

Необходимо разбить исходную строку на максимальное количество частей таким
образом, чтобы каждая буква встречалась только в одной части.

Сначала для каждой буквы найдем индекс ее первого и последнего вхождения
в строку (функция __get_idx_map).

Пусть есть строка s = 'ababcc'. Буква 'a' встречается на позициях 1 и 3,
значит s[:3] точно не может быть разбита. Между вхождениями буквы 'a' есть
буква 'b', которая находится на позициях 2 и 4, значит s[1:4] тоже нельзя
разделить. В итоге получаем часть строки длина минимум 4. Другие буквы в
него не входят, значит его можно отедлить от строки.

Если представить индексы первого и последнего вхождения каждой буквы как
отрезки на числовой прямой, то пересекающиеся отрезки как раз образуют
одну часть. В итоге задача сводится к подсчету длины таких частей. Если
начало нового отрезка лежит внутри текущей части, то обновляем конец этой
части, иначе - заносим длину части в ответ и накапливаем длину следующей.

Лучшее решение: 0 ms, 17.48 Mb
"""


class Solution:

    def __get_idx_map(self, s: str) -> dict[str, list[int]]:
        d = dict()
        i = 0
        for letter in s:
            if letter not in d:
                d[letter] = []
            d[letter].append(i)
            i += 1
        for k, v in d.items():
            if len(v) > 2:
                d[k] = [v[0], v[-1]]
            if len(v) == 1:
                d[k] = [v[0], v[0]]
        return d

    def partitionLabels(self, s: str) -> list[int]:
        d = self.__get_idx_map(s=s)
        start = end = 0
        ans = []
        for v in d.values():
            if v[0] <= end:
                end = max(end, v[1])
            else:
                ans.append(end - start + 1)
                start, end = v
        ans.append(end - start + 1)
        return ans
