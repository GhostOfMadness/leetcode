"""
Meeting Rooms III.

Есть n комнат и массив meetings, задающий время начала и окончания встреч.
Каждая встреча проходит в свободной комнате с наименьшим номером. Если
свободных комнат нет, то встреча откладывается, пока одна комната не
освободится. Отложенные встречи проводятся в том же порядке, что должны
были изначально. Время старта встреч не повторяется. Найти номер комнаты
(при индексации с 0), где пройдет наибольшее количество встреч.

Создадим 2 кучи:
- free - очередь свободных в данный момент комнат, на вершине расположен
  наименьший номер свободной комнаты.
- occupied - мин. куча занятых комнат, на вершине расположена комната,
  которая освободится раньше всех. Если несколько комнат освободятся в одно
  время, то на вершине будет наименьший номер.

Отсортируем встречи по времени старта. Проходимся циклом по массиву встреч.
Сначала извлекаем из кучи occupied номера комнат, которые освободятся ко
времени начала текущей встречи, и заносим их в кучу free. Если очередь free
не пуста, то извлекаем элемент на вершине, увеличиваем счетчик встреч в этой
комнате на 1 и заносим эту комнату в occupied. Так как к моменту начала
встречи нашлась пустая комната, то встреча начнется и закончится в положенное
время, значит в occupied с номером комнаты заносится исходное время окончания
встречи. Если очередь free пуста, то свободных комнат нет. Значит встреча
пройдет в первой освободившейся комнате, номер которой на вершине occupied.
Извлекаем вершину occupied, увеличиваем счетчик для комнаты на 1. Сдвинулось
время начала встречи, значит сдвинется и время окончания, но общая
длительность не меняется. То есть ко времени, когда освободится комната,
нужно добавить длительность текущей встречи, и занести полученную пару
время - комната в occupied.

Для ответа находим первое вхождение максимального значения счетчика.

Лучшее решение: 176 ms, 51.55 Mb
"""
import heapq


class Solution:

    def mostBooked(self, n: int, meetings: list[list[int]]) -> int:
        meetings.sort()
        free = list(range(n))
        occupied = []
        heapq.heapify(free)
        heapq.heapify(occupied)
        rooms = [0] * n
        for start, end in meetings:
            while occupied and occupied[0][0] <= start:
                heapq.heappush(free, heapq.heappop(occupied)[1])
            if free:
                room = heapq.heappop(free)
                rooms[room] += 1
                heapq.heappush(occupied, (end, room))
            else:
                t, room = heapq.heappop(occupied)
                rooms[room] += 1
                heapq.heappush(occupied, (t + end - start, room))
        return rooms.index(max(rooms))
