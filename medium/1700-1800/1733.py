"""
Minimum Number of People to Teach.

Существует n языков. i-й человек знает languqges[i] языки (один или несколько).
В массиве friendships перечислены пары друзей, при этом эта связь не
транзитивна, то есть если A дружит с B, а B - с C, то это не значит, что A
дружит с C. Чтобы друзья могли общаться друг с другом, им нужно знать хотя
бы один общий язык. Можно выбрать ровно один из существующих языков и обучить
ему любое количество людей. Нужно найти такой язык, чтобы количество дообучений
было минимально, и вернуть как раз это количество.

Если пара друзей уже может общаться друг с другом, то исключаем ее из
рассмотрения. А среди остальных пар необходимо найти язык, который знает
самое большое количество человек, и дообучить ему всех остальных. Для этого
создаем словарь lang_cnt, массив visited (по условии может быть не больше 500
человек, поэтому можно сделать массив с запасом, чтобы не тратить время на
поиск реального кол-ва людей и обработки тех, кто входит в "хорошие" пары)
и счетчик people_cnt. Проходимся по всем парам в массиве friendships. Если
множества значений языков не пересекаются, то заполняем словарь. Для этого
проверяем, что эти люди еще не были рассмотрены в других парах, для каждого
из языков в их сетах увеличиваем знаение в словаре lang_cnt на 1 и наращиваем
общий счетчик людей "плохих" парах. Ответом будет разница между общим кол-вом
людей и кол-вом тех, кто знает самый популярный язык.

Лучшее решение: 52 ms, 27.32 Mb
#hash_table #array
"""


class Solution:

    def minimumTeachings(
        self,
        n: int,
        languages: list[list[int]],
        friendships: list[list[int]]
    ) -> int:
        lang_cnt = dict()
        visited = [False] * 500
        people_cnt = 0

        def fill_dict(idx: int, people_cnt: int):
            if not visited[idx]:
                for lang in languages[idx]:
                    lang_cnt[lang] = lang_cnt.get(lang, 0) + 1
                visited[idx] = True
                people_cnt += 1
            return people_cnt

        for u, v in friendships:
            if not set(languages[u - 1]) & set(languages[v - 1]):
                people_cnt = fill_dict(u - 1, people_cnt)
                people_cnt = fill_dict(v - 1, people_cnt)
        return people_cnt - max(lang_cnt.values(), default=0)
