"""
Maximum Subarray.

В данном массиве целых чисел найти подмассив с наибольшей суммой чисел.

Самым простым решением будет перебор всех возможных вариантов, который займет
O(n^2) по времени, что неэффективно на больших массивах. Поэтому попробуем
убрать те варианты, которые заведомо не подходят. Рассмотрим все подмассивы
от 0-го элемента. На некотором индексе j для него находится конец оптимального
ответа, то есть движение от j вправо не улучшает его. Для получения значений
всех подмассивов для индекса 1 достаточно вычесть 0-й элемент из уже найденных
префиксов. То есть прошлый набор значений изменится на одно и то же число.
Мы знаем, что прошлый оптимальный ответ оканчивался на j, а теперь мы вычли из
тех значений одинаковое число, то есть точка оптимума не сдвинулась. Для
индекса 1 наибольший подмассив также заканчивается на позиции j. И это верно
для всех индексов для j включительно. Таким образом, вместо перебора всех
вариантов для этих индексов мы уже точно знаем позицию конца нужного
подмассива. После индекса j берем максимум на оставшемся участке и проводим
такие же рассуждения. Повторяем, пока не дойдем до конца массива.

Подход состоит в разбиении массива на участки между максимумами и поиска
ответа на данном участке. Для быстрого расчета на отрезке используем префиксы.
Пусть есть отрезок [i, j], где i < j - позиции соседних максимумов, тогда
prefix[j] - min(prefix[i:jъ, 0) будет ответом на этом участке. Общий ответ
собираем как максимум из ответов для отрезков.

Можно немного изменить эту идею и не хранить префиксы и позиции максимумов.
Будем хранить текущее значение префикса и минимальное значение префикса, но
не на конкретном отрезке между максимумами, а на участке от начала до текущего
индекса. Такая замена не влияет на ответ. Проходимся по всем элементам массива
и добавляем текущее значение к префиксу. Если элемент положительный, то
префикс точно увеличился относительно прошлого значения. Находим разницу между
текущим префиксом и минимумом и обновляем ответ. Если элемент отрицательный,
то сравниваем его с ответом, так как в массивах только отрицательных чисел
ответом будет наибольший элемент. В конце обновляем значение минимального
префикса.

Лучшее решение: 43 ms, 31.46 Mb
#array #divide_and_conquer
"""


class Solution:

    def maxSubArray(self, nums: list[int]) -> int:  # 53 ms, 30.83 Mb
        ans = float('-inf')
        length = len(nums)
        prefix = [nums[0]] * length
        for i in range(1, length):
            prefix[i] = prefix[i - 1] + nums[i]
        prev = prefix[-1]
        currMin = 0
        for i in range(length - 2, -1, -1):
            val = prefix[i]
            if val < currMin:
                currMin = val
            if val > prev:
                add = prev - currMin
                if add > ans:
                    ans = add
                prev = val
                currMin = 0
        add = prev - currMin
        if add > ans:
            ans = add
        return ans

    def maxSubArray2(self, nums: list[int]) -> int:  # 43 ms, 31.46 Mb
        ans = nums[0]
        prefix = nums[0]
        minPrefix = nums[0]
        for i in range(1, len(nums)):
            prefix += nums[i]
            if nums[i] > 0:
                sub = min(minPrefix, 0)
                if prefix - sub > ans:
                    ans = prefix - sub
            elif nums[i] > ans:
                ans = nums[i]
            if prefix < minPrefix:
                minPrefix = prefix
        return ans
