"""
Fruits Into Baskets.

Массив fruits состоит из целых неотрицательных чисел, каждое из которых
является типом фрукта на дереве i. Фрукты можно собирать в 2 корзины,
в каждой из которых может быть неограниченное количество одного типа фрукта.
Начать сбор можно с любой позиции. Когда дошли до дерева с фруктом, который
нельзя собрать, останавливаемся. С каждого дерева можно взять только 1 фрукт.
Найти максимальное количество фруктов, которое можно собрать.

Задача сводится к тому, что необходимо найти максимальную длину подмассива,
состоящего только из 2-х уникальных элементов. Заведем переменные first
и second, в которых будем хранить индексы последних вхождений используемых
фруктов в текущее окно. Длина окна определяется переменной curr.

Если тип нового фрукта совпадает с одним из имеющихся или второй еще не был
определен, то увеличиваем размер окна на 1 и обновляем нужный индекс.
В ином случае обновляем ответ и корректируем curr. Теперь в окно будет входить
только тот тип фрукта, который стоял последним в предыдущем окне. То есть
текущий размер окна состоит из количества вхождений этого типа, начиная от
последнего вхождения другого типа, к которому добавляется 1 на новый элемент:
i - min(first, second) - 1 + 1 = i - min(first, second)
first устанавливаем на i - 1, second - на i.

Лучшее решение: 45 ms, 23.66 Mb
"""


class Solution:

    def totalFruit(self, fruits: list[int]) -> int:
        first = 0
        second = None
        ans = 0
        curr = 1
        for i in range(1, len(fruits)):
            if fruits[i] == fruits[first]:
                curr += 1
                first = i
            elif not second or fruits[i] == fruits[second]:
                curr += 1
                second = i
            else:
                ans = max(ans, curr)
                curr = i - min(first, second)
                first = i - 1
                second = i
        return max(ans, curr)
