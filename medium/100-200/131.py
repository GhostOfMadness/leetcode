"""
Palindrome Partitioning.

Найти все возможные разбиения строки на подстроки, каждая из которых непуста
и является палиндромом.

В обоих решениях используется рекурсия с возвратом, аргументом которой
является индекс начала. В первом случае проходим циклом от начального индекса
до конца строки. На каждом шаге смотрим на полученную подстроку. Если она
является палиндромом, то добавляем ее в текущее разбиение и вызываем рекурсию
от оставшейся подстроки за этим палиндромом. После выхода из рекусии удаляем
из текущего разбиения добавленное значение. Если начальный индекс при запуске
рекурсии равен длине строки, то добавляем текущее разбиение в ответ.

Во втором случае сначала делаем предварительные вычисления. Для каждого
индекса строки находим длины палиндромов, которые начинаются с этого индекса.
Для этого используем динамическое программирование. С его помощью можно найти,
палиндромы какой длины заканчиваются на i-м индексе (см. объяснение к задаче
5), но, зная конечный индекс и длину, можно легко найти начало палиндрома.
Найденные значения сохраняем в pmap. Рекурсия также запускается от индекса,
но теперь нет перебора и проверки всех строк от этого индекса. Вместо этого
проходим по всем длинам палиндромов для этого индекса. Добавляем палиндром
в текущее разбиение и вызываем рекурсию от индекса idx + длина добавленного
палиндрома. После выхода из рекурсии удаляем из рабиения добавленный палиндром
и переходим к следующему шагу. Обновляем ответ, когда индекс запуска стал
равен длине строки.

Количество рекурсивных вызовов одинаково, но во втором случае нет перебора
и медленной проверки каждой из подстрок, поэтому этот вариант работает
быстрее, но требует память на хранение словаря.

Лучшее решение 1: 49 ms, 34.32 Mb
Лучшее решение 2: 29 ms, 34.48 Mb
#backtracking #dynamic_programming
"""


class Solution:

    def partition1(self, s: str) -> list[list[str]]:
        self.ans = []
        self.curr = []
        self.n = len(s)

        def rec(idx=0):
            if idx == self.n:
                self.ans.append(self.curr[:])
            else:
                prev = ''
                for i in range(idx, self.n):
                    curr_str = prev + s[i]
                    if curr_str == curr_str[::-1]:
                        self.curr.append(curr_str)
                        rec(i + 1)
                        self.curr.pop()
                    prev = curr_str

        rec()
        return self.ans

    def __get_palindrome_map(self, s: str, n: int):
        dp = [1]
        prev = s[0]
        i = 1
        ans = {i: [1] for i in range(n)}
        for letter in s[1:]:
            curr = [1]
            if letter == prev:
                curr.append(2)
                ans[i - 1].append(2)
            for e in dp:
                idx = i - e - 1
                if idx >= 0 and s[idx] == letter:
                    curr.append(e + 2)
                    ans[idx].append(e + 2)
            dp = curr
            i += 1
            prev = letter
        return ans

    def partition2(self, s: str) -> list[list[str]]:
        n = len(s)
        pmap = self.__get_palindrome_map(s, n)
        curr = []
        ans = []

        def rec(idx=0):
            if idx == n:
                ans.append(curr[:])
            else:
                for plen in pmap[idx]:
                    curr.append(s[idx: idx + plen])
                    rec(idx + plen)
                    curr.pop()
        rec()
        return ans
