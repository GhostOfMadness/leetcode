"""
Longest Subarray of 1's After Deleting One Element.

Дан массив nums, состоящий из нулей и единиц. Найти длину наибольшего
подмассива, состоящего только из единиц, после удаления одного элемента.

Используем метод 2-х указателей. Левый указатель ставим в начало массива,
а правый будем сдвигать каждый раз на 1 в цикле. Если элемент равен единице,
то продолжаем движение. Если элемент равен 0 и это первый ноль, который
встретился при движении, то заносим его индекс в zero_idx и идем дальше.
На окне допустим один ноль, который как раз можно удалить и соединить
последовательности единиц слева и справа от него. Если ноль уже не первый на
окне, то обновляем ответ на максимум из него самого и длины текущего окна
за минусом 1 (удаленный элемент) и сдвигаем левый указатель на позицию
zero_idx + 1. Если ноль на окне был в начале или середине окна, то левый
указатель встанет на начала последовательности единиц справа от него. Если
ноль был в конце, то левый указатель будет равен правому.

После выхода из цикла также обновляем ответ на длину оставшегося окна.

Лучшее решение: 12 ms, 21.84 Mb
"""


class Solution:

    def longestSubarray(self, nums: list[int]) -> int:
        ans = 0
        left = 0
        zero_idx = None
        for right in range(len(nums)):
            if nums[right] == 0:
                if zero_idx is not None:
                    curr_len = right - left - 1
                    if curr_len > ans:
                        ans = curr_len
                    left = zero_idx + 1
                zero_idx = right
        return max(ans, right - left)
